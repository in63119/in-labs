---
title: "WebAuthn Passkey 온보딩 구조: 이메일 없이 가입"
date: "2025-02-07"
tags: ["WebAuthn", "Passkey", "Auth", "Next.js", "NestJS"]
summary: "이메일/비밀번호 없이 가입하는 패스키 온보딩 플로우. App Router(Next.js) + NestJS 서버 예시와 UX 체크리스트를 포함합니다."
---

> 목적: 이메일 없이도 가입과 로그인이 가능한 **패스키(공개키 인증)** 온보딩을 최소 구현으로 정리합니다.  
> 구성: 개념 → 전체 플로우 → 서버(NestJS) → 클라이언트(Next.js App Router) → UX/보안 체크.

## 1) 패스키 개념 한 줄 요약

- WebAuthn은 **기기 내 보안 하드웨어**가 만들고 보관하는 **비대칭 키(공개/개인키)** 로 인증합니다.
- 서버는 **공개키**만 저장하고, 로그인 때 **서명 검증**으로 사용자 소유를 확인합니다.
- 비밀번호가 없어 **피싱 위험**, **재사용**, **유출** 부담이 크게 줄어듭니다.

---

## 2) 전체 온보딩 플로우

[클라이언트] [서버]
| |
| 1) 등록 옵션 요청 | (RP ID, challenge, userId 등 생성)
|-------------------->|
| |
| 2) navigator.credentials.create() (기기에서 키 생성)
|<--------------------|
| |
| 3) 등록 결과 전송 | (공개키/attestation 검증, DB 저장)
|-------------------->|
| |
| 4) 완료/세션 발급 |
|<--------------------|

로그인(인증)도 유사합니다. `navigator.credentials.get()`으로 기기 서명을 받고, 서버가 **challenge** 기준으로 서명을 검증합니다.

---

## 3) 사전 준비 체크리스트

- 도메인/서브도메인 확정. **RP ID**는 일반적으로 최상위 도메인(예: `in-labs.example`).
- HTTPS 환경. 로컬은 `http://localhost` 예외 허용.
- 서버에 보관할 컬럼: `userId`, `credentialId`, `publicKey`, `counter`, `transports`, `createdAt`, `lastUsedAt`.
- 라이브러리: 서버는 `@simplewebauthn/server`, 클라이언트는 `@simplewebauthn/browser` 권장.

---

## 4) 서버 예시(NestJS)

> 엔드포인트 4개: 등록 옵션 발급, 등록 검증, 로그인 옵션 발급, 로그인 검증.

```ts
// auth.controller.ts
import { Body, Controller, Post } from '@nestjs/common';
import {
  generateRegistrationOptions,
  verifyRegistrationResponse,
  generateAuthenticationOptions,
  verifyAuthenticationResponse,
} from '@simplewebauthn/server';
import type {
  GenerateRegistrationOptionsOpts,
  GenerateAuthenticationOptionsOpts,
  VerifiedRegistrationResponse,
  VerifiedAuthenticationResponse,
} from '@simplewebauthn/server';

const rpName = 'In Labs';
const rpID = 'in-labs.example'; // 실제 도메인으로 교체
const origin = `https://${rpID}`;

@Controller('webauthn')
export class WebAuthnController {
  // 임시 저장소 예시(실무는 DB 사용)
  private users = new Map<
    string,
    {
      id: string;
      username: string;
      currentChallenge?: string;
      credentials: Array<{
        credentialID: string;
        publicKey: string;
        counter: number;
        transports?: AuthenticatorTransport[];
      }>;
    }
  >();

  @Post('registration/options')
  async regOptions(@Body() body: { username: string }) {
    const user =
      [...this.users.values()].find(u => u.username === body.username) ??
      (() => {
        const id = crypto.randomUUID();
        const u = { id, username: body.username, credentials: [] as any[] };
        this.users.set(id, u);
        return u;
      })();

    const opts: GenerateRegistrationOptionsOpts = {
      rpName,
      rpID,
      userID: user.id,
      userName: user.username,
      attestationType: 'none',
      authenticatorSelection: {
        residentKey: 'preferred',
        userVerification: 'preferred',
      },
      excludeCredentials: user.credentials.map(c => ({
        id: Buffer.from(c.credentialID, 'base64url'),
        type: 'public-key',
        transports: c.transports,
      })),
    };

    const options = await generateRegistrationOptions(opts);
    user.currentChallenge = options.challenge;
    return options;
  }

  @Post('registration/verify')
  async regVerify(
    @Body()
    body: {
      username: string;
      attestationResponse: any; // Client에서 받은 결과 전체
    },
  ) {
    const user = [...this.users.values()].find(u => u.username === body.username);
    if (!user || !user.currentChallenge) {
      throw new Error('User or challenge not found');
    }

    const verification: VerifiedRegistrationResponse = await verifyRegistrationResponse({
      response: body.attestationResponse,
      expectedChallenge: user.currentChallenge,
      expectedOrigin: origin,
      expectedRPID: rpID,
      requireUserVerification: false,
    });

    if (!verification.verified || !verification.registrationInfo) {
      throw new Error('Registration verification failed');
    }

    const { credentialID, credentialPublicKey, counter } = verification.registrationInfo;
    user.credentials.push({
      credentialID: Buffer.from(credentialID).toString('base64url'),
      publicKey: Buffer.from(credentialPublicKey).toString('base64url'),
      counter,
    });
    user.currentChallenge = undefined;

    // 여기서 세션/토큰 발급 등 처리
    return { ok: true, userId: user.id };
  }

  @Post('authentication/options')
  async authOptions(@Body() body: { username: string }) {
    const user = [...this.users.values()].find(u => u.username === body.username);
    if (!user) throw new Error('User not found');

    const opts: GenerateAuthenticationOptionsOpts = {
      rpID,
      userVerification: 'preferred',
      allowCredentials: user.credentials.map(c => ({
        id: Buffer.from(c.credentialID, 'base64url'),
        type: 'public-key',
        transports: c.transports,
      })),
    };

    const options = await generateAuthenticationOptions(opts);
    user.currentChallenge = options.challenge;
    return options;
  }

  @Post('authentication/verify')
  async authVerify(
    @Body()
    body: {
      username: string;
      assertionResponse: any;
    },
  ) {
    const user = [...this.users.values()].find(u => u.username === body.username);
    if (!user || !user.currentChallenge) throw new Error('User or challenge not found');

    const credential = user.credentials.find(
      c => c.credentialID === body.assertionResponse.id,
    );
    if (!credential) throw new Error('Credential not found');

    const verification: VerifiedAuthenticationResponse = await verifyAuthenticationResponse({
      response: body.assertionResponse,
      expectedChallenge: user.currentChallenge,
      expectedOrigin: origin,
      expectedRPID: rpID,
      authenticator: {
        credentialID: Buffer.from(credential.credentialID, 'base64url'),
        credentialPublicKey: Buffer.from(credential.publicKey, 'base64url'),
        counter: credential.counter,
        transports: credential.transports,
      },
    });

    if (!verification.verified || !verification.authenticationInfo) {
      throw new Error('Authentication verification failed');
    }

    // 카운터 업데이트(재플레이 공격 방지)
    credential.counter = verification.
```
